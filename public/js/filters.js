// Generated by CoffeeScript 1.7.1
(function() {
  var Gradient, lerp;

  lerp = function(v0, v1, t) {
    return v0 + (v1 - v0) * t;
  };

  Gradient = function(from, to) {
    this.from = from;
    this.to = to;
    this.width = to - from;
    return this;
  };

  Caman.Plugin.register("myTiltShift", function(radius, focus_center, gradient_height_upper, gradient_height_lower, gradient_distance_upper, gradient_distance_lower) {
    var blur_kernel, divisor, height, i, j, kernel_size, lower_gradient, new_value, pixels, t, upper_gradient, width, x, x_div, x_k, y, y_div, y_k, _i, _j, _k, _l, _m, _n;
    if (isNaN(radius) || radius < 1) {
      return;
    }
    pixels = this.pixelData;
    width = this.dimensions.width;
    height = this.dimensions.height;
    focus_center = focus_center || (height / 2);
    gradient_height_upper = gradient_height_upper | 50;
    gradient_height_lower = gradient_height_lower | 50;
    gradient_distance_upper = gradient_distance_upper || 20;
    gradient_distance_lower = gradient_distance_lower || 20;
    upper_gradient = new Gradient(focus_center - gradient_height_upper - gradient_distance_upper, focus_center - gradient_distance_upper);
    lower_gradient = new Gradient(focus_center + gradient_distance_lower, focus_center + gradient_distance_lower + gradient_height_lower);
    kernel_size = radius * 2 + 1;
    divisor = kernel_size * kernel_size;
    blur_kernel = new Array();
    for (y = _i = 0; 0 <= kernel_size ? _i < kernel_size : _i > kernel_size; y = 0 <= kernel_size ? ++_i : --_i) {
      blur_kernel[y] = new Array();
      for (x = _j = 0; 0 <= kernel_size ? _j < kernel_size : _j > kernel_size; x = 0 <= kernel_size ? ++_j : --_j) {
        blur_kernel[y][x] = 1;
      }
    }
    for (y = _k = 0; 0 <= height ? _k < height : _k > height; y = 0 <= height ? ++_k : --_k) {
      for (x = _l = 0; 0 <= width ? _l < width : _l > width; x = 0 <= width ? ++_l : --_l) {
        if (y >= upper_gradient.to && y <= lower_gradient.from) {
          break;
        }
        i = y * width * 4 + x * 4;
        new_value = new Array();
        new_value[0] = 0;
        new_value[1] = 0;
        new_value[2] = 0;
        for (y_k = _m = 0; 0 <= kernel_size ? _m < kernel_size : _m > kernel_size; y_k = 0 <= kernel_size ? ++_m : --_m) {
          for (x_k = _n = 0; 0 <= kernel_size ? _n < kernel_size : _n > kernel_size; x_k = 0 <= kernel_size ? ++_n : --_n) {
            y_div = y_k - radius;
            x_div = x_k - radius;
            if ((y + y_div) < 0 || (y + y_div) >= (height - 1)) {
              y_div = 0;
            }
            if ((x + x_div) < 0 || (x + x_div) >= (width - 1)) {
              x_div = 0;
            }
            j = (y + y_div) * width * 4 + (x + x_div) * 4;
            new_value[0] += pixels[j] * blur_kernel[y_k][x_k];
            new_value[1] += pixels[j + 1] * blur_kernel[y_k][x_k];
            new_value[2] += pixels[j + 2] * blur_kernel[y_k][x_k];
          }
        }
        new_value[0] /= divisor;
        new_value[1] /= divisor;
        new_value[2] /= divisor;
        if (y > upper_gradient.from && y <= upper_gradient.to) {
          t = (y - upper_gradient.from) / upper_gradient.width;
          new_value[0] = lerp(new_value[0], pixels[i], t);
          new_value[1] = lerp(new_value[1], pixels[i + 1], t);
          new_value[2] = lerp(new_value[2], pixels[i + 2], t);
        }
        if (y > lower_gradient.from && y <= lower_gradient.to) {
          t = (y - lower_gradient.from) / lower_gradient.width;
          new_value[0] = lerp(pixels[i], new_value[0], t);
          new_value[1] = lerp(pixels[i + 1], new_value[1], t);
          new_value[2] = lerp(pixels[i + 2], new_value[2], t);
        }
        pixels[i] = new_value[0];
        pixels[i + 1] = new_value[1];
        pixels[i + 2] = new_value[2];
      }
    }
    return this;
  });

  Caman.Filter.register("myTiltShift", function(radius, focus_center, gradient_height_upper, gradient_height_lower, gradient_distance_upper, gradient_distance_lower) {
    return this.processPlugin("myTiltShift", [radius, focus_center, gradient_height_upper, gradient_height_lower, gradient_distance_upper, gradient_distance_lower]);
  });

}).call(this);
